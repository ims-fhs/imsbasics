---
title: "workflow-and-style"
author: "SQC, SCN"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    number_sections: yes
    theme: united
    toc: yes
  pdf_document:
    fig_caption: yes
    highlight: tango
    number_sections: yes
    toc: yes
---

***


# IMS (R-) style guide

External Sources are

* Prio 1 [Hadley style guide](http://stat405.had.co.nz/r-style.html)
* Prio 2 [Google style guide](https://google.github.io/styleguide/Rguide.xml)

Thus, if Hadley and Google contradict each other, use Hadley

## Mindset

See article (at the moment on arXiv) "Best Practices for Scientific Computing" 
by Wilson et. al. 

* Write programs for people, not computers.
    - a program should not require its readers to hold more than a handful of 
    facts in memory at once
    - names should be consistent, distinctive and meaningful
    - code style and formatting should be consistent
    - all aspects of software development should be broken down into tasks 
    roughly an hour long
* Automate repetitive tasks.
    - rely on the computer to repeat tasks
    - save recent commands in a file for re-use
    - use a build tool to automate scientific workflows
* Use the computer to record history.
    - software tools should be  used to track computational work automatically
* Make incremental changes.
    - work in small steps with frequent feedback and course correction
* Use version control.
    - use a version control system
    - everything that has been created manually should be put in version control
    - keep the size of the files small!
* Use a backup for all data. version control does not make sense for data
* Don’t repeat yourself (or others).
    - every piece of data must have a single authoritative representation in the system
    - code should be modularized rather than copied and pasted
    - re-use code instead of rewriting it
* Plan for mistakes.
    - add assertions to programs to check their operation
    - use an off-the-shelf unit testing library
    - use all available oracles when testing programs
    - turn bugs into test cases
    - use a symbolic debugger
* Optimize software only after it works correctly.
    - use a profiler to identify bottlenecks
    - write code in the highest-level language possible
* Document design and purpose, not mechanics.
    - document interfaces and reasons, not implementations
    - refactor code instead of explaining how it works
    - embed the documentation for a piece of software in that software
* Collaborate.
    - use pre-merge code reviews
    - use pair programming when bringing someone new up to speed and when 
    tackling particularly tricky problems

## Naming Conventions

* Folders: `meaningful name` or `meaningfulname`
* Files end with '.R': `meaningful-file.R`
* Objects (Variables and Classes): `meaningful_variable`
* Functions: `meaningful_function`
* Packages: `mngflabrr` Trade of between: googleable, remindable, selfexplainable, 
short etc. see also [Hadley](http://r-pkgs.had.co.nz/package.html#package-structure)
again.

## Versioning 

Adapted from <http://semver.org/> and <http://yihui.name/en/2013/06/r-package-versioning/>.

Given a version number MAJOR.MINOR.PATCH, increment the:

* MAJOR version when you make incompatible API changes,
* MINOR version when you add functionality in a backwards-compatible manner that 
is worth writing a few lines (in the description file) and creating a GitHub Tag, and 
* PATCH version when you make a commit to your development branch. (bugfix, 
feature or minor change)

Process in case re-writing code is necessary:
1. merge all relevant branches into master branch and review the result.
2. re-write the code and commit. Review the result.
3. don't forget to push!

## Indentation  

When indenting your code, use two spaces.  Never use tabs or mix tabs and spaces.
Spacing
Place spaces around all binary operators (=, +, -, <-, etc.).
Do not place a space before a comma, but always place one after a comma.
Place a space before left parenthesis, except in a function call.

## General Layout and Ordering

1. Copyright statement comment
2. Author comment
3. File description comment, including purpose of program, inputs, and outputs
4. source() and library() statements
5. Function definitions
6. Executed statements, if applicable (e.g., print, plot)

Unit tests should go in a separate file named `test-originalfunction(s).R`. See 
testthat package for documentation. Implemented tests from  [Hadley](https://journal.r-project.org/archive/2011-1/RJournal_2011-1_Wickham.pdf)

Full | Short cut
------------- | -------------
expect_that(x, is_true()) | expect_true(x)
expect_that(x, is_false()) | expect_false(x)
expect_that(x, is_a(y)) | expect_is(x, y)
expect_that(x, equals(y)) | expect_equal(x, y)
expect_that(x, is_equivalent_to(y)) | expect_equivalent(x, y)
expect_that(x, is_identical_to(y)) | expect_identical(x, y)
expect_that(x, matches(y)) | expect_matches(x, y)
expect_that(x, prints_text(y)) | expect_output(x, y)
expect_that(x, shows_message(y)) | expect_message(x, y)
expect_that(x, gives_warning(y)) | expect_warning(x, y)
expect_that(x, throws_error(y)) | expect_error(x, y)

Include non-standard packages using `libraray(package)`
Use the following structure for packages

* /package/data/: RData (Output).
* /package/inst/extdata/: Data which have to be accessible by the user of the package.
* /package/tests/testthat/: All relevant rawdata for tests - keep the size small!
[source](http://r-pkgs.had.co.nz/data.html)

For customer projekts we need

* /project/data/rawdata/yyyy/: subfolder for rawdata for year yyyy.
* /project/data/yyyy/: working directory includes all analysis for year yyyy.

## Testing

Unit tests should go in a separate directory, see testthat package for documentation.  
The tests contain
* a helper-file for
    - loading data
    - check that test data's uuid has not changed and
    - limits for benchmark tests (`t_fast_us`, `t_fast_ms` and `t_slow`)
* test files named `test-originalfunction(s).R`
* benchmark tests and
* a test which checks the result for consistency ("Simulation outcome ok").

## Project management and documentation

### Documentation

Work-In-Progress is documented on the Symphonical wall of the project in form 
of a User Story.

1. R packages are documented with vignette(s). For examples see 
[here](http://r-pkgs.had.co.nz/vignettes.html#vignette-workflow)
2. Every project has a starUML document describing the software architecture of 
the project according to the 
[4+1 view model](https://en.wikipedia.org/wiki/4%2B1_architectural_view_model).

### Count Story Points - R-script

Export Symphonical as JSON file and run the R script in the appendix.  
Goal is a monthly evaluation.

***


# R, Rtools and Rstudio

## Install R and Rtools

For windows: Install latest R version from [CRAN](https://cran.r-project.org/bin/windows/base/)
and install it to C:/R/R-x.x.x. Do not install it to the program folder because 
you will run into trouble with admin right.  

To build an R package in Windows, you will need to install some additional 
software tools. These are summarized [here](http://cran.r-project.org/bin/windows/Rtools/)

### Rtools

This is a collection of unix-like tools that can be run from the DOS command 
prompt. It also contains the MinGW compilers that are used for compiling Fortran 
and C code. You should download and run the version corresponding to the flavour 
of R you are using. When asked, choose the default “Package authoring 
installation” to build add-on packages.

Install the latest Rtools version to C:/Rtools. The file (It is not a package) 
can be downloaded from [here](https://cran.r-project.org/bin/windows/Rtools/)
Be careful with path conventions. R needs "/"!

```
Be careful: Here, you have to add the system path "C:/R/R-x.x.x/bin;"
```
To reach the path see 
`Systemsteuerung -> System und Sicherheit -> System -> Erweiterete Einstellungen`
=> Umgebungsvariablen...

Follow the steps in [Fox](http://socserv.mcmaster.ca/jfox/Courses/R/ICPSR/R-install-instructions.html).

### MikTeX

MikTeX is used for producing the pdf help files. You can produce an R package 
without it, but the package will not contain pdf help files. Most of you will 
have this installed anyway. Download from [here](http://www.miktex.org)

## Install RStudio

Install Editor from [here](https://www.rstudio.com/products/rstudio/download/)
Most likely you have to install further packages.
Either go to Rstudio and use the console
```
> install.packages(c("devtools", "testthat", "ggplot2", "knitr", "lme4", "MBESS", 
  "mi", "polycor", "readxl", "rgl", "rmarkdown", "sem", "sfsmisc"))
```
or use the built in package Editor => Install
```
Important note: Install packages always to C:/R/R-x.x.x/
```

**ToDO: .libPaths() = "C:/R/R-3.2.2/library"**
**ToDo: How to update R properly?** See [here](http://stackoverflow.com/questions/1401904/painless-way-to-install-a-new-version-of-r-on-windows)

It might also be useful to install [MikTex](http://miktex.org/download) to be 
able to use Rmarkdown.

Finally, make sure, you installed the packages

* devtools used for downloading and installing code from github and 
* testthat for standardized unit tests.

When you want to automate testing open or create a project (including package) 
and type the following command in the R console:
```
> devtools::use_testthat()
```
This creates the test_that folders. When you change the project in RStudio, you 
start with a **clear environment** and a **clear shell**. For Details see 
Hadley "R packages", Ch. 7. 

## Update R

<http://stackoverflow.com/questions/1401904/painless-way-to-install-a-new-version-of-r-on-windows>

## Install a package with auth_token

In RStudio use the following command in the R console
```
devtools::install_github("ims-fhs/repo", auth_token = "35b77ed8d745a9572409e6c153e20e36d45094ed")
```
Most up to date auth_token = "3bdb5ca1735725c6dd270e487eca41fea1c75f20"

***

# The Shell, Git and GitHub

## The shell

### The shell: first steps for Linux shell (or bash?)

For windows cmd commands see next section!
A (Linux) shell can be opened in Rstudio via Rstudio => Tools => Shell...
Notation for the cd-command.  
You can find the help for any command via help command, e.g. `help cd`  
There you will find  
`cd [-L|-P] [dir]`.  
Here, `[]` means an optional argument and `|` means "either or".  

To change the directory type 
```
> cd C:/ # go from C:/somewhere/ to C: Windows CMD: cd\
> cd C: # go from H: to C: 
```
The "." notation refers to the working directory itself and the ".." notation 
refers to the working directory's parent directory.
Sometimes you can also find

  * `ls -r` or
  * `ls --reverse`
These two commands are identical and the arguments just read `--longargument = -abbreviatedarg`.
The first variant is fast to write, the second one is easy to read and understand.

Run an Rscript: Go to the directory of `myfile.R`, then in Windows cmd
```
> Rscript "myfile.R"
```

### The shell: overview over windows cmd commands

The following commands are possible:

* [Navigation](http://linuxcommand.org/lc3_lts0020.php) `cd, pwd`, e.g.
    - `> cd /d C`: Change the directory. cmd.exe behaves like DOS.
* [Looking](http://linuxcommand.org/lc3_lts0030.php) around `ls, less, file`
    - `q` = Quit!
* [Manipulating files](http://linuxcommand.org/lc3_lts0050.php) `cp, mv, rm, mkdir`
    - `rm name`: Remove file `name`.
    - `mv oldname newname`: Rename a file.
    - Wildcards * and ?, e.g. cp *.txt existingdirectory
* [Commands](http://linuxcommand.org/lc3_lts0060.php) `type, which, help, man`, 
e.g. `help cd`
* [I/O redirection](http://linuxcommand.org/lc3_lts0070.php)
* [Expansions](http://linuxcommand.org/lc3_lts0080.php)
* [Permissions](http://linuxcommand.org/lc3_lts0090.php)
* [Jobcontrol](http://linuxcommand.org/lc3_lts0100.php)
* [Writing shell scripts](http://linuxcommand.org/lc3_writing_shell_scripts.php)

Link for [further reading](http://linuxcommand.org/lc3_learning_the_shell.php)

### The shell: some useful commands for programming

* `assoc`: View file associations. 
    - `assoc [.ext[=[FileType]]]`Use `.ext` to specify the file name extension 
    whose association you want to view or change and `FileType` to specify the 
    file type with which you want Windows to associate the specified file name extension.
* `COMMAND /?`: Show help for `COMMAND`
* `ECHO %variable%`: Display value of existing variable.
* `FTYPE`: Run as administrator! Displays file types used in file name extension associations.
    - `Ftype [FileType[=[OpenCommandString]]]`: Specifies the open command to 
    use when opening files of this type. Add
    _ `%0` or `%1` are replaced with the file name that you want to open.
    - `%*` is replaced with all of the parameters.
    - `%~ n` is replaced with all of the remaining parameters, starting with the 
    nth parameter, where n can be any number from 2 to 9.
    - `%2` is replaced with the first parameter, %3 with the second, and so on.
* `pathto\Rscript.exe pathto\file.R`: Execute file via command line
* `robocopy "source" "destination" /e /mir /np /z /tee /mt /log:my_backup_log.txt"`: 
Useful backup tool.
* `set variable=VALUE`: Assign value to new `variable`.
    - `set _oldvariable=VALUE`: Assign value to existing `oldvariable`.
    - `set`: Display all existing variables.
    - `set prefix`: Display all existing variables ending with `prefix`.
    - `set variable=`: Delete `variable`.
* `VAR=`: Delete `VAR`
* `<` and `>`: Use `<` to redirect input, and `>` to redirect output.
  `command1 > file1` executes `command1`, placing the output in `file1`, 
  as opposed to displaying it at the terminal, which is the usual destination for 
  standard output. This will clobber (overwrite) any existing data in `file1`.  
  Using `command1 < file1` executes `command1`, with `file1` as the source of 
  input, as opposed to the keyboard, which is the usual source for standard input.
* `>>`: To append output to the end of the file, rather than clobbering it, 
  the `>>` operator is used: `command1 >> file1` to read from a stream literal 
  (an inline file, passed to the standard input), one can use a here document, 
  using the `<<` operator.
* `|`: Piping, that means programs can be run together such that one program 
reads the output from another with no need for an explicit intermediate file:
A pipeline of three programs run on a text terminal `command1 | command2` executes 
`command1`, using its output as the input for `command2` (commonly called 
piping, with the `|` character being known as "pipe").

### Assign programs to files, e.g. make R executable (not working yet?)

See <http://www.r-bloggers.com/making-r-files-executable-under-windows/>
Choosing a new file extension name (.Rexec) so that the default behaviour is not 
overwritten. I suggest using .Rexec for R scripts that should be executable while 
leaving the default system behaviour for .R files as is. 

In the next step, we tell Windows that the .Rexec file extension is associated 
with the RScriptExecutable file type. Furthermore, we inform Windows how these 
kind of files should be opened by default.

Within the command line, type:
```
> ASSOC .Rexec=RScriptExecutable
```
then
```
> FTYPE RScriptExecutable=C:Program FilesRR-3.1.2binx64Rscript.exe %1 %*
```
while making sure that the path used above really leads to your most 
recent/preferred `RScript.exe`. 

To test if everything works as expected, create an R script with the following lines:
```
message(getwd())
for(i in 1:100) {
  cat(".")
  Sys.sleep(0.01)
}
message("nBye.")
Sys.sleep(3)
```
Save it as, e.g., 'test.Rexec' and double click on the file. Now a black box 
should pop up, informing you about the current working directory, and printing 
100 dots on the screen and terminate itself after saying 'Bye'. 

## Git

### Introduction to version control: Git (or SVN?)

Short version of a good answer from 
[here](http://stackoverflow.com/questions/871/why-is-git-better-than-subversion):
The key feature of git is that it is decentralized. Imagine you are a developer on 
the road, you develop on your laptop and you want to have source control so that 
you can go back 3 hours.

With Subversion, you have a Problem: The SVN Repository may be in a location 
you can't reach (in your company, and you don't have internet at the moment), 
you cannot commit. If you want to make a copy of your code, you have to 
literally copy/paste it.

With Git, you do not have this problem. Your local copy is a repository, and 
you can commit to it and get all benefits of source control. When you regain 
connectivity to the main repository, you can commit against it.
This looks good at first, but just keep in mind the added complexity to this approach.

... First of all, Git can be really confusing at first when working 
decentralized. What is a remote? and How to properly set up the initial 
repository? are two questions that come up at the beginning ... The documentation 
of the "checkout" command is very confusing to people changing over - the "proper" 
way seems to be "git clone", while "git checkout" seems to switch branches.

Git REALLY shines when you are decentralized. It's an extra command though 
(`git commit` commits locally, whereas `git push origin master` pushes the 
master branch to the remote named "origin"). As said above: Git adds complexity. 
Two modes of creating repositories, checkout vs. clone, commit vs. push... 
You have to know which commands work locally and which work with "the server"...

... Git is perfectly suited for Open Source projects: Just Fork it, commit your 
changes to your own Fork, and then ask the original project maintainer to pull 
your changes. With Git, this just works. Really, try it on Github, it's magic.

But even with this lengthy addition, I still stand by my core message: Git is 
not better or worse, it's just different. If you have the need for "Offline 
Source Control" and the willingness to spend some extra time learning it, it's 
fantastic.

Looking back, I strongly recommend to **read at least the first three chapters**
of the [git tutorial](https://git-scm.com/book/en/v2/). Here, you will learn about
* staging,
* commiting,
* and what it all means...
Therefore, getting fluent with git on the console is very useful.. (eventhough it 
might look like wasting your time in the first place. I (Adrian) didn't believe 
Christoph in the first place and had to learn it on the hard tour..)

![Git Data Transport](GitDataTransport.png)

Remark concerning RStudio:

    Only if the file is part of a package or project in Rstudio, 
    "everything" can be done from the git-ribbon in Rstudio! (But some things have
    to be done via shell!)

### Git: Installation on Windows

Git for Windows is provided as installer package by the msysgit project. 
Download the latest package starting with "Git-", not a "msysgit-..." package 
(the latter are supposed to be used to build git yourself). Git for Windows 
comes with a UNIX environment as far as needed by git and also ships with a 
Bash shell for using the git command line tools. Settings during installation: 
* Git from Windows cmd (save way), then
* Checkout windows style, commit in Unix style line endings, then
* Use winTTY.

Further useful literature:

* [Hadley](http://r-pkgs.had.co.nz/git.html): How to set up Rstudio, git/SVN and github.
* [Github](https://help.github.com/articles/fetching-a-remote/) help on git's 
clone, fetch, pull, merge.

### Git: first steps and quick tour for impatient guys (RTFM!!!)

Open a shell (e.g. from RStudio) and test some basic commands:
```
> where git # Shows, where git.exe is located
> git version # Shows the version
> git config --list --show-origin # View config file and location (> V2.8).
```
The last command shows all your config files and their content. In general, we 
have the following hirarchy of config files:

* System level (--system): OS level
* User (--global): The file will be placed under your %HOME% folder.
* Project (--local): Specific definitions for the given project. This file is 
located in the project under `.git/config`.

I have the following locations (Windows):
```
file:"C:\\ProgramData/Git/config"       ...
file:"C:\\Git\\mingw64/etc/gitconfig"   ???
file:C:/Users/sqc/.gitconfig            ...
file:.git/config                        ...
```

If you want to have access to all commmands (e.g. alias names) from Windows cmd, you 
need to set the `user variable` `HOME=C:\Users\sqc` (Backslash! `%USERPROFILE%` Not 
tested). Git searches for the global config file in `%HOME%` (which is not set by 
default on Windows). For further details see Appendix.

Now we are ready to start. You can use the following commands to track and 
understand what is going on. For explanations see below. 
**All these commands are save** and you can't screw anything up!
```
> git status
> git branch -av
> git remote show origin
> git log # for an elegant way see below `git git config --global alias.hist` 
```

Git internally holds a thing called the index, which is a **full snapshot** of your 
project content (more than files!). After you have just created an empty repository, 
the index will be empty. You must manually stage the files from your working tree
to the index using `git add`:  
```
> git add somefile.txt
```
`git add` works recursively, so you can also add whole folders:  
```
> git add somefolder
```

If you have changes which you want to track in the feature, you have to commit them 
afterwards using a commit message (the `-m`)
```
> git commit -m "My first commit"
```

The same applies if you change a file in your working tree - you have to add 
this change to the index with `git add`:  
```
> git add somefile.txt
```
Only then you can commit again. The following should be clear: The first time, 
you say "here is a new file I want to commit" - then you commit. The second time, 
git realises that "there is a changed file you should commit"!

If you want to list all the files **currently being tracked** under the branch 
"master", you could use this command:
```
> git ls-tree -r master --name-only
```
As already said: the use the following commands frequently and understand what 
git tells you:
```
> git status
> git branch -av
> git remote show origin
> git log # for an elegant way see `git hist` 
```

If you want git to ignore some files and/or folders, create a `.gitignore` file 
in the root folder of your project and edit it with your favorite editor. It looks
something like
```
.Rhistory # Comment here
files.whatever

Folders/
```
See [gitignore](https://git-scm.com/docs/gitignore) for further details.

### Git: useful commands

All commands can be prompted to the console. The `> git...` input is ommitted 
in the list. Some commands concern github topics. For further information 
concerning github read the next chapter.  
In the following, we assume that we have an existing github repository 
"https://github.com/ims-fhs/myfolder". 

#### A

* `add file`: Add file to tracking, e.g. `git add myfile.txt` (Only useful after 
you start with commitments.)  
If `git add`is not successful, **look at your .gitignore file**.
    - `add .`: Looks at the working tree and adds all those paths to the staged 
    changes if they are either changed or are new and not ignored, it does not 
    stage any 'rm' actions.
    - `add -u`: Looks at all the already tracked files and stages the changes 
    to those files if they are different or if they have been removed. It does 
    not add any new files, it only stages changes to already tracked files.
    - `add -A` is equivalent to `git add .` + `git add -u`.
    - `add folder/*`: Add folder to git.

#### B

* `branch` Note: A branch in Git is simply a lightweight movable pointer to one 
of these commits. The default branch name in Git is master. The only reason nearly 
every repository has one is that the git init command creates it by default and 
most people don’t bother to change it. As you start making commits, you’re given 
a master branch that points to the last commit you made. Every time you commit, 
it moves forward automatically.
    - `branch newbranch`: Create new branch "newbranch". 
    - `branch -d branch`: Delete branch.
    - `branch -v`: Display branches including description.
    - `branch -r`: Display remote branches.
    - `branch -l`: Display local branches.
    - `branch -av`: Display all branches including remotes and description of each.
    - `branch --merged`: Display all merged branches.
    - `branch -u remoteserver/branch localbranch` (`-u` = `--set-upstream`):
    Corresponds to `git config branch.localbranch.remote remoteserver` + 
    `git config branch.localbranch.merge refs/heads/localbranch` This is very 
    useful to be sure the upstream references are right before you push or pull! 
    Because `git branch -u remoteserver/branch localbranch` doesn't mess up nothing..
    - `branch -m oldname newname`: Rename a branch while pointed to any branch. 
    If you want to rename the current branch, you can simply do 
    `git branch -m newname`

#### C

* `checkout branch`: Switching to a specific, existing **LOCAL** branch. Update files in the 
working tree to match the version in the index or the specified tree. If no paths 
are given, git checkout will also update HEAD to set the specified branch as the 
current branch. To prepare for working on a branch, switch to it by updating the 
index and the files in the working tree, and by pointing HEAD at the branch. Local 
modifications to the files in the working tree are kept, so that they can be 
committed to the branch. This command doesn't make any changes to the history nor 
any repository.
    - `checkout -b localbranch`: create localbranch and switch to it at the same 
    time (= `git branch name` + `git checkout name`).
    - `checkout -b newbranch remoteserver/remotebranch`: Checkout and create a 
    copy of the LOCAL `remoteserver/remotebranch`. Furthermore, the branch is being set up 
    to track the remote branch, which usually means the remoteserver/remotebranch 
    branch. This is of interest if you you want to join a project.
    In case of a "**fatal** git checkout: updating paths is incompatible with 
    switching branches...": This occurs when you are trying to checkout a remote 
    branch that your local git repo is not aware of yet See `git remote show origin`.
    If the remote branch is under "New remote branches" and not "Tracked remote 
    branches" then you need to `fetch` them first - see `fetch`.
    - `checkout -b newbranch HEAD`: If you have a **detached HEAD** you can use 
    this command to assign newbranch to the detached HEAD.
    - `checkout shorthash` on Commit-level: Switch between branches or inspect 
    old snapshots. See `git log` for possible hash keys. As result you end up 
    with a **detached HEAD**. This is on purpose, as you can play around without 
    consequences. Read the note after command is executed!
    With a subsequent `git checkout lastbranch` you go back as if nothing had happend.
    **This is even true, when you modified and commit the old version. All changes 
    are lost!** In case you meesed things up (e.g. `git checkout notlastbranch`) 
    and you don't want to keep changes see `git reset --hard HEAD`.
    - `checkout @{-1}`: Checkout previous branch. @{-1} is always a way to 
    refer to the last branch you were on. 
    - `checkout file` on file-level: Discard changes after a `git reset file` 
    in the working directory.
* `clean -f`: Remove (= delete) untracked files.
    - `clean -f -n`: Don’t actually remove anything, just show what would be done.
    - `clean -fd`: Force removing Remove untracked directories in addition to 
    untracked files. 
    - `clean -x`: **WARNING** also removes all ignored files!
* `clone`: Clones a repository into a newly created directory, creates 
remote-tracking branches for each branch in the cloned repository, and creates 
and checks out an initial branch that is forked from the cloned repository’s 
currently active branch. E.g. `git clone https://github.com/ims-fhs/myfolder`.  
The default shortname for the remote server is then **origin**.
    - `clone --depth n --branch branchname repo directory`: Clone history up 
    to nth commit, only `branchname` from `repo` and `folder`.
* `commit`: Commit changes to current branch (If you just started to work, it 
will be called `master`)
    - `commit -a -m "text"`: Stage everything (-a, could be also done with a 
    preceding add files) and attach text (Comment) to the commit. See also log.
    - `commit --amend`: This command takes your staging area and uses it for the
    commit. You can edit the message as always, but it overwrites 
    your previous commit. If you’ve made no changes since your last commit 
    (for instance, you run this command immediately after your previous commit), 
    then your snapshot will look exactly the same, and all you’ll change is your 
    commit message. The same commit-message editor fires up, but it already 
    contains the message of your previous commit.
    Do **not use `--amend` option after you pushed the last commit**. In this 
    case you have to merge the two.
* `config` : Configure git. 
    - `config --list` or `config --list --show-origin`: List all configurations; 
    in the ladder case with the origin of the file (only working for Git >2.8). 
    Git checks 4 places for a configuration file:
        + System config: Your machine's system `.gitconfig file`.
        + User config: Your user .gitconfig file located at `~/.gitconfig`.
        + A second user-specific configuration file located at 
        `$XDG_CONFIG_HOME/git/config` or `$HOME/.config/git/config`.
        + Repo-specific config: The local repo's config file .git/config.
    The settings cascade in the following order, with each file adding or 
    overriding settings defined in the file above it.  
    You can see what each file has defined using the following commands:
    - `config --system --list`: List all system configurations. Be careful when 
    you change it. In the worst case you have to **reinstall everything**.
    - `config --global --list`: List all global configurations.
    - `config varname`: Display the value of git variable varname. 
    - `config --global alias.myshortname Realgitcommand`: Introduce shortcut
    for "Real git command", e.g. `config --global alias.ci "commit -v"`.
    Be careful: If the command uses a white space "..." (Windows) or '...' (Linux)
    is needed. Excample for a complex command (working on windows!):
        + `git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"`.
        + `git config --global alias.taghist "log --no-walk --date-order --tags --simplify-by-decoration --pretty=format:'%ai %h %d'"`
        + `git config --global alias.ignoreall "status --porcelain | grep '^??' | cut -c4- >> .gitignore"`
    - `config --global --unset varname`: Delete global `varname`, e.g. 
    `alias.myshortname` shortcut. Does not work, if several `varname` with the 
    same name exist.
    - `config --global --unset-all varname`: Delete all global 
    `varname`, e.g. `alias.myshortname` shortcuts
    - `git config --get-regexp alias`: List all defined alias names.
    - `config --global --replace-all core.editor "'pathtoexe/exename`: Set 
    global editor for windows. Be careful with spaces. `--replace-all` only necessary 
    in case of wrongly set multiple editors.
    - `config --global --edit`: View your config file

#### D

* `diff` Show changes between the working tree and the index or a tree, changes 
between the index and a tree, changes between two trees, changes between two 
blob objects, or changes between two files on disk.
    - `diff remotename/branchname:remote/path/file1.txt local/path/file1.txt`:
    View the differences going from the remote file to the local file. Only
    commited changes are visible.
    - `diff HEAD:local/path/file1.txt remotename/branchname:remote/path/file1.txt`:
    View the differences in the other direction. Only commited changes are visible.
    - `diff ref1:path/to/file1 ref2:path/to/file2`: Diff any two files anywhere 
    using this notation. As usual, ref1 and ref2 could be branch names, 
    remotename/branchname, commit SHAs, etc.
    - `diff A..B` or `diff A...B`: See
    [stackoverflow](http://stackoverflow.com/questions/5256249/git-diff-doesnt-show-enough/5257065#5257065)
    - `diff --cached file`: Used, if changes are not staged or commited yet.
    - `diff -c file`: Combine old and new version of a file.
* `difftool` is a frontend to git diff and accepts the same options and arguments.
    - `difftool -t=kdiff3 branch1 branch2` to specify external editor kdiff3. 
    See appendix for further explanations concerning **interference with RStudio**.
    - `difftool -y -t=kdiff3 branch1 branch2`: Use `-y` option to suppress confirmation.
    - `difftool -t=kdiff3 HASH1 HASH2`: Show differences between two HASHes 
    - `difftool -t=kdiff3 remotename/branchname:remote/path/file1.txt local/path/file1.txt`
    or `difftool -t=kdiff3 branch1 branch2 file.txt`: Use any of those 
    combinations to compare a specific `file.txt` in two branches.

#### F

* `fetch remoteserver remotebranch`: Update remote branch, that is refresh "what 
others do". Usual case `fetch origin remotebranch`; Get all data from branch on 
the origin (Normally the remoteserver has shortname origin, see clone!). No merging!

#### I

* `init`: Initialize git repository. This command creates basically a .git 
directory with subdirectories for objects, refs/heads, refs/tags, and template 
files. An initial HEAD file that references the HEAD of the master branch is 
also created. Therefore, right after `git init`, the master branch is not visible
after `git branch -av`. This only happens, after the first commit. Before, you're 
said to be "on an unborn branch", at this point.  
If the repo already exists, the history will not be deleted. The primary reason 
for rerunning `git init` is to pick up newly added templates (or to move the 
repository to another place if `--separate-git-dir` is given).  
The default name for the starting branch is **master**.

#### L

* `log`: Show the whole commit history.
    - `log -2`: Show last two commits.
    - `log --pretty=format "%h - %an, %ad: %s:"`: Nice format, shows 
    hash - authorname, date: commitcomment.
    - `log --oneline --decorate`: Show branches including pointers.  
        + `--decorate`: Print out the ref names of any commits that are shown. If short is specified,
        the ref name prefixes refs/heads/, refs/tags/ and refs/remotes/ will not be 
        printed. If full is specified, the full ref name (including prefix) will be 
        printed. The default option is short.
        + `--oneline <sha1> <title line>` : This is a shorthand for `--pretty=oneline --abbrev-commit` used together.
    - `log --follow name`: Continue listing the history of a file `name`. 
    beyond renames (works only for a single file).
    - `log --date-order --graph --tags --simplify-by-decoration --pretty=format:"%ai %h %d"`:
    List all tags with dates
    - `log --tags`: List all commits and tags including all details.
    - `log --no-walk --tags --pretty=format:"%d, %h - %an, %ad: %s" --date=short`: List 
    all tags only including all details. `%d` stands for ref names, like the 
    `--decorate` option of git-log

#### M

* `merge branch`: Merge branche into the one which is actice (HEAD points 
onto it. See `git branch -av`): If you changed the same part of the same file 
differently in two branches you’re merging together, Git won’t be able to merge 
them cleanly and an error results. Use "status" to get the unmerged files. In 
this case the version in HEAD (your master branch, if you have checked out that 
when you ran your merge command) is the top part of that block (everything 
above the =======)
* `mv oldname newname`: Rename file `oldname`. 
* `mv oldname newname`: Rename a file. Shorthand for `mv oldname newname` + 
`git add newname` + `git rm oldname`. For religion see
[here](http://permalink.gmane.org/gmane.comp.version-control.git/217).

#### P

* `pull remoteserver remotebranch`: Begin tracking file by doing this from 
the master branch. `pull = fetch + merge`
    - `pull remoteserver remotebranch:localbranch`: **Pay Attention** because 
    you fetch to localbranch (which is ok) but the merge is to the present branch 
    which might not be ok, if remotebranch does not exist. Then you have to run 
    first git checkout -b remotebranch first.
    - `pull -u remoteserver`: Equivalent to `--update-head-ok` and different from 
    `push -u`! By default git fetch refuses to update the head which corresponds to the 
    current branch. This flag disables the check. This is purely for the internal 
    use for git pull to communicate with git fetch, and unless you are 
    implementing your own Porcelain you are not supposed to use it.

* `push remoteserver localbranch:remotebranch`: Pushing localbranche to the 
repository remotename (Normally called origin) in remotebranch. If only one 
branch is specified, it is assumed that localbranch = remotebranch.  
    - `push remoteserver :remotebranch`: Pay **attention: **deletes** the remotebranch. 
    - `push -u remoteserver remotebranch`: Necessary if you want git pull to know 
    what to do. "Upstream" refers to the main repo that other people will be 
    pulling from, e.g. your GitHub repo. The -u option automatically sets that 
    upstream for you, linking your repo to a central one. That way, in the future, 
    Git "knows" where you want to push to and where you want to pull from, so you 
    can use git pull or git push without arguments. A little bit down, this article 
    explains and demonstrates this concept. “Tracking” is essentially a link between a local 
    and remote branch. When working on a local branch that tracks some other 
    branch, you can git pull and git push without any extra arguments and git 
    will know what to do. However, git push will by default push all branches 
    that have the same name on the remote. To limit this behavior to just the 
    current branch, set this configuration option: 
    `git config --global push.default tracking`
    - `push --all remoteserver`: Push (and pull!) all the branches to the 
    remoteserver by default, including the newly created ones. Combination 
    `-u --all` possible.
    - `push --tags remoteserver`: Push (and pull!) all tags to remoteserver.
    - `push --mirror`: Create identical copy of current folder. **Not tested**
    `push --mirror` = `push --all` + `push --tags`.
    - `push origin :refs/tags/tagname`: Delete the tag `tagname` on the 
    remoteserver `origin`

#### R
* `rebase branch`: Similar to merge - kind of rewrites history, which can be 
summed up in a single line: **Do not rebase commits that exist in other peoples' repository.**
If you follow that guideline, you’ll be fine. If you don’t, people will hate 
you, and you’ll be scorned by friends and family. When you rebase stuff, 
you’re abandoning existing commits and creating new ones that are similar but 
different. If you push commits somewhere and others pull them down and base 
work on them, and then you rewrite those commits with git rebase and push them 
up again, your collaborators will have to re-merge their work and things will 
get messy when you try to pull their work back into yours. Again, read 
[here](https://git-scm.com/book/en/v2/Git-Branching-Rebasing).
* `remote`: Needed when using and managing remote repoitories. Remote repositories 
are versions of your project that are hosted on the Internet or network somewhere. 
You can have several of them. Collaborating with others involves managing these 
remote repositories and pushing and pulling data to and from them when you need 
to share work. Be careful with fork (Github).
    - `remote -v`: Use argument verbose (-v), which shows you the URLs that Git 
    has stored for the shortname to be used when reading and writing to that remote 
    - `remote show remoteserver`: Show information about remoteserver including
    upstream settings (if set).
    -  `remote add remoteserver server`: Add remoteserver of server to tracking. 
    E.g. `git remote add origin https://github.com/ims-fhs/myfolder`.
    Only visible after a push!
    - `git remote set-url`: Change your remote's URL from SSH to HTTPS with the 
    it remote set-url command. E.g.  
    `git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git`
    And change it back:  
    `git remote set-url origin git@github.com:USERNAME/OTHERREPOSITORY.git`
    - `remote rename oldremoteserver newremoteserver`: Rename oldremoteserver to 
    newremoteserver.
    - `remote rm remoteserver`: Remove remoteserver.
    - `remote show remoteserver`: Show details from remoteserver. Good to check wether
    remoteserver exists.
* `reset` **is an exteremly dangerous method**. It can be used if you messed 
things up and it is ok when you loose **all uncommited changes**. Therefore, you 
shoud check your last commit before you reset as this commit is where you end up with 
    - `reset file` on file-level: Unstage a file (Not dangerous)
    - `reset --hard HEAD` on commit-level: Discard commits in a private branch or 
    throw away uncommited changes. Permanently undo uncommitted changes in case 
    of a detached HEAD.
* `revert hash`: This command creates a new commit that undoes the changes from a 
previous commit. This command adds new history to the project (it doesn't 
modify existing history). Therefore, it is a “safe” way to undo a single commit— it
does not “revert” back to the previous state of a project by removing all subsequent 
commits. In Git, this is actually called a reset, not a revert.
* `rm -r --cached folder`: remove `folder` from tracking including subfolders
(-r = recursive) but keep the files in the folder (`--cached`).
* `rm -r --cached .`: remove all unstaged files from tracking (-r = recursive) 
but keep the files in the folder (`--cached`).

#### S

* `stash`: Use `git stash` when you want to record the current state of the 
working directory and the index, but want to go back to a clean working directory. 
The command saves your local modifications away and reverts the working directory 
to match the HEAD commit. The latest stash you created is stored in refs/stash; 
older stashes are found in the reflog of this reference and can be named using 
the usual reflog syntax (e.g. stash@{0} is the most recently created stash, 
stash@{1} is the one before it).
    - `stash list`: List the modifications stashed away 
    - `stash show`: Inspected modification.
    - `stash apply`: Restore modifications (potentially on top of a different commit) 
* `status`: Get the status, displays **tracked AND Untracked** (=new!) files,
**Modified** files and **Branches**
    - `status --porcelain | grep '^??' | cut -c4- >> .gitignore`: Move all 
    untracked files to `.gitignore`. Format manually afterwards...  
        + `status --porcelain` is used instead of `status --short` because manual 
        states "Give the output in an easy-to-parse format for scripts. This is 
        similar to the short output, but will remain stable across git versions 
        and regardless of user configuration." So we have both the parseability 
        and stability;
        + `grep '^??'` filters only the lines starting with ??, which, according 
        to the git status manual, correspond to the untracked files;
        + `cut -c4-`: `-c` marks the beginning of a list of column numbers to cut. 
        `4-` selects the line from column 4 to the end, which cuts columns 1-3. 
        So the `cut` command actually removes the first 3 characters of each line.
        + For the rest see explanation of shell commands

#### T
   
* `tag`: list all tags. A Tag is a specific point in history, e.g. the 
publication of the code (Release V1.0).
    - `tag -a version -m text`: Create an annotated tag with tagging version of 
    type v0.1.0 and message text = "my text" or the commit checksum 
    (something like "67a465f").
    - `tag -a version HASH -m text`: Create an annotated tag as above for old 
    commit HASH.
    - `tag -l "xy"`: Search for tags starting with xy.
    - `tag -l -n99`: List all tags including first 99 lines of the annotations.
    - `tag -d tagname`: Delete tag in current branch. See `push` for deleting 
    the tag remotedly.

### Advanced Git: hooks - the pre-commit hook
For example files see appendix. The process is as follows:

* Copy the text in the appendix into a file and save it as `pre-commit` 
in /.git/hooks/ **without any ending**.
* Depending on the operating system and your path to Rscript. As first line use
    - Windows: #!C:/R/R-3.2.2/bin/x64/Rscript or
    - Mac OSX:  #!/Library/Frameworks/R.framework/Versions/3.2/Resources/bin/Rscript  
    and make the file executable:
    ```
    chmod +x filename.sh
    ```
    including prefix if existing.
* As described in the R-file, the version increases automatically.
* If you don't want to increase the version run

    `SET inc=FALSE`  
    `git commit -a -m "Your message"`

**If you increase the minor or major version, the patch is set to 0.**

* SET does not work for MAC OSX. Workaround to be found.

For a complete list see [here](http://ss64.com/nt/).


## Github

We have the following existing accounts

* symbolrush (User)
* Christoph999 (User)
* ims-fhs (Organisation with rights to set folders as private)

The following tools at the github page are really useful, especially, if you try 
to understand what is going on with git:

* Graphs => Network

Keep in mind: You can do a lot of stuff in github, but only using the shell you 
create a consitent history where ou can go back if something unexpected happend!

## GitHub: set your credentials
You can set your credentials to prevent to insert your username and password all 
the time on the git shell.

For MAC OSX follow 
[these](https://help.github.com/articles/caching-your-github-password-in-git/) 
instructions.

## Github: concerning fork and branch

When talking about version control, we have to distinguish "fork a branch" and 
"Create a new branch": In contrast to "branch", **"fork" is a pure github to github 
operation** where all branches on GitHub will be copied (Obviously, this doesn’t include 
branches that were never pushed to GitHub in the first place.). Nothing is copied 
to your PC. It’s notquite the same as a Git clone. See the manual for git-clone(1) 
if you wonder “what’s copied when I clone a project?”. You cannot always make a 
branch or pull an existing branch and push back to it, because you are not 
registered as a collaborator for that specific project. Forking is nothing more 
than a clone on the GitHub server side:

  * without the possibility to directly push back
  * with fork queue feature added to manage the merge request 
  
You keep a fork in sync with the original project by:

  * adding the original project as a remote
  * fetching regularly from that original project
  * rebase your current development on top of the branch of interest you got 
  updated from that fetch.  

The rebase allows you to make sure your changes are straightforward (no merge 
conflict to handle), making your pulling request that more easy when you want 
the maintainer of the original project to include your patches in his project.  
The goal is really to allow collaboration even though direct participation is 
not always possible. See [here](http://stackoverflow.com/questions/3611256/forking-vs-branching-in-github)
for more information, escpessially for the difference between **upstream** and 
**origin**

For further reading see [here](https://www.ralfebert.de/tutorials/git/) and
[here](https://git-scm.com/docs/).

***


# Getting started with git and github - Useful cases

## Case 1: You want to join a project

Assume you have an existing github repo 
<https://github.com/ims-fhs/myfolder>.
and you want to join working on it. Do the following steps:
```
> cd working directory           # Go the place for the new folder
> git clone https://github.com/ims-fhs/myfolder # clone repo
> git push -u origin master      # Eventually: Restart RStudio if the Arrows 
    in the Git Section of RStudio are greyed out.
```
Create a new branch `devXXX`, where `XXX` stands for your name. This ensures you 
don't work on the master branch directly, but on a development branch of your own.
```
> git checkout -b devXXX
```
... Work on the project...  
and set the upstream for your development branch and pushes it back to origin:
```
> git push -u origin devXXX 
```
After this step the tag of your branch on github (network graph) should be 
aligned with the master tag.

If you have already existing files, just copy them in the new folder by hand.
Otherwise create a new file... All changes will then be visible in git! 

If you have reached a certain status you want to share, do the following two 
steps:
    - Rstudio => Git -> Commit
    - Rstudio => Git -> Push (Only works, if you are a collaborator and when 
    previous `push -u` was successful.)

## Case 2: You want somebody else to join your project

Assume you worked on "myproject" project or package or folder and you 
want others to join your project.

* If it is not a project yet: Rstudio => Create new project or package. 
You can set up the default to create a **git repository**. If the 
default "create git repo" was not set, do
    - shell `> cd working directory` (The place for the new folder)
    - shell `> git init`
and
    - Rstudio => Tools => Project options => Git/SVN ... Use Git!
    - Rstudio => Tools => Global options => Git/SVN .. Use Git!
* Create github repo <https://github.com/ims-fhs/myproject>.
and add your partner as collaborator (Github repo => Settings => Collaborators 
and teams.

Your partner must do the following:
```
> git remote add origin https://github.com/ims-fhs/myproject # See github!
> git pull origin master # pull files from origin (defined above!) to master
> git push -u origin master # set upstream reference
```

version control in Rstudio can be only accessed within an project. If you have a folder 
which is not specified as project or package use the Rstudio project dialog...
File => New project => Existing directory => specify parent folder of file.

## Case 3: You forgot to first pull the project, somebody worked on the remote repo 

You already made your changes when you read this document. Then commit:
```
> git commit -a -m "text"
> git status
```
The status should be `detachedHEAD`. Therefore, you cannot push you changes 
because you're in `detachedHEAD` status. Procede as follows:
```
> git checkout -b newbranch # You have to checkout the remote repository into a new branch
> git checkout master
> git merge newbranch # Now you can merge the newbranch from above with your local master
```
Now you can delete the newbranch and push the changes back to the remote repository
```
> git branch -d newbranch
> git push -u origin master
```

## Case 4: Commit the work you did in RStudio GUI
You changed a file and want to commit your work. Within R Studio go to Git 
=> Diff. Select the file you want to commit. The lower part of the editor shows 
your changes:

* red: Everything you deleted
* green: Everything you added

### You want to commit everything you changed
Insert a comment to the window topright that explains the changes you made. Press 
commit.

### You want to commit only part of what you changed
* Select the part you don't want to commit, with `shift` held down. Press `unstage selection`.
* Repeat until only the parts you want to commit are shown in the `staged` window.
* Rest as above...

### You changed something you didn't want to change
You made false changes to a file and want to correct them **before** you commit.  
Within R Studio go to Git => Diff. Select the file you want to repair. The lower 
part of the editor shows your changes:

* red: Everything you deleted
* green: Everything you added

* Select the parts you changed by fault, with `shift` held down. Press `unstage selection`.
* Repeat until only the changes you want to be preserved are shown in the `staged` window.
* Change to the `unstaged` window
* Select the parts you changed by fault, with `shift` held down. Press `Discard selection`.

## Case 5: You worked on a project and want to pass it to github

Create a folder in Github. Then open a shell in your project and add the remote 
repository as a branch (?):
```
> git remote add origin https://github.com/account/remotefolder/
```
Ensure the remote is set right with 
```
> git remote show origin
```
Push your master branch to the remote repo:
```
> git push -u origin master
> git remote show origin
```
The latter command will tell you the master pushes and pulls to remote/master.
See also `git push -u --all`!

[Reference](http://stackoverflow.com/questions/7927230/remove-directory-from-remote-repository-after-adding-them-to-gitignore)

## Case 6: Remove directory DIR from remote repository after adding them to .gitignore

All the data git uses info is stored in .git/ , so removing it is fine. Of 
course, make sure that your working copy is in the exact state that 
you want it, because everything else will be lost. The /.git folder is hidden so 
make sure you turn on Show hidden files, folders and disks option.

* Add the folder path to your directories's root /.gitignore file.  
`path2DIR/DIR/`  
In case DIR is subfolder of your root directory, you only need to add `DIR/`
* Remove the folder from your local git tracking, but keep it on your disk.  
`git rm -r --cached path2DIR/DIR/`
* Commit and push your changes to your git repo.
```
> git commit -m "Message"  
> git push origin master  
```
  
You can't delete the file from your history without rewriting the history of 
your repository - you shouldn't do this if anyone else is working with your 
repository, or you're using it from multiple computers. If you still want to 
do that, you can use git filter-branch to rewrite the history - 
[there is a helpful guide to that here](https://help.github.com/articles/remove-sensitive-data/).

## Case 7: You face a staging area with too many files which you never expect to be part of your project
This means that `git status` shows untracked file on a higher level. It could 
happen as follows: You had a repo and you cloned it. You ran `git clone url/to/repo.git` 
from your directory say /home/repos/my. Now after the clone, you try `git status` 
and it shows untracked files from /home/repos.

So how is this possible?

1. You must have had a .git folder (probably an artifact of previous failed 
clone, etc) in /home/repos ( or even /home etc.)
2. Since you did git clone url/to/repo.git, git would have created a folder 
repo at /home/repos/my/repo. But you did the git status from /home/repos/my. 
So git goes to parent folders looking for .git and found it (as per 1) and hence 
shows untracked files.

So see if 2) is your case. Try changing directory to the folder that git has 
created. Usually you should do a clone as git clone url/to/repo.git. (. at end) 
if you are already in the folder where you want the repo to be.

## Case 8: When do I use revert, reset, checkout

If you have modified a file in your working tree, but haven't committed the change, 
then you can use git checkout to checkout a fresh-from-repository copy of the file.

If a commit has been made somewhere in the project's history, and you later 
decide that the commit is wrong and should not have been done, then git revert 
is the tool for the job. It will undo the changes introduced by the bad commit, 
recording the "undo" in the history. If it was the previous commit, the first 
choice is `git commit --amend`.

In all other cases use `git revert` to record some new commits to reverse the 
effect of some earlier commits (often only a faulty one). If you want to throw 
away all uncommitted changes in your working directory, you should see git-reset[1], 
particularly the --hard option. If you want to extract specific files as they 
were in another commit, you should see git-checkout[1], specifically the git 
checkout <commit> -- <filename> syntax. Take care with these alternatives as 
both will discard uncommitted changes in your working directory.

If you have made a commit, but haven't shared it with anyone else and you decide 
you don't want it, then 

* show your problem somebody experienced
* and use `git reset` to rewrite the history so that it looks as though you 
never made that commit. **This is really dangerous!**

## Case 9: You completely messed up git for unknown reasons but a working older version is on github.
First: Delete your local folder, try `git clone`.

If for some unhappy reason this doesn't work, try the following:
Rename your messed up folder. Then you create a completely(!) new folder with 
subfolders - renamaing the old folder won't help...  
Then copy the necessary bare files, e.g. .png, .R, ... to the new folders.

Create a new package, initialize git (`git init`) and commit you changes "First 
commit after rebuilding". Then proceed as in 4.6 using a newbranch(!).
History is then clear and you are save as you last changes are in the previous 
commit and the history is in newbranch.
Think about what happend and merge master (your last changes) into newbranch.
In the end you need `git push -u origin newbranch. You can merge master and 
newbranch later on when you feel save.


## Case 10: You want run "git add -A ." in each submodule.

**his is not recommended**: You should carefully change into each 
submodule in turn, and consider how you want to update them, treating each as 
a standalone repository. Then only commit these new submodule versions in the 
main project when you have tested that the project as a whole works with those 
new versions of each submodule.

Use git status to see untracked files. Empty folders are only visible, when you
start to commit files in these new folders.

```
git submodule foreach --recursive git add -A .
```
And then you could create a commit in every submodule with:
```
git submodule foreach --recursive "git commit -m 'Committing in a submodule'"
```
(If you don't have other submodules nested inside those submodules, the 
`--recursive` option is unnecessary.)  

## Case 11: You want to remove a file, a folder, ... from git tracking

Do the following steps (inbetween it looks like you delete everything, but that 
will go away for some reasons)
**I assume that everything you want to commit is commited!**
```
git rm -r --chached . # =all or specify folder, file
git add .
git commit -a -m "Remove ... from tracking"
```

# Debugging

Some useful hints from [here](http://adv-r.had.co.nz/Exceptions-Debugging.html)

It’s a great idea to adopt the scientific method. Generate hypotheses, design 
experiments to test them, and record your results. This may seem like a lot of 
work, but a systematic approach will end up saving you time. I often waste a lot 
of time relying on my intuition to solve a bug (“oh, it must be an off-by-one 
error, so I’ll just subtract 1 here”), when I would have been better off taking 
a systematic approach.

**Fix it and test it:** Once you’ve found the bug, you need to figure out how 
to fix it and to check that the fix actually worked. Again, it’s very useful to 
have automated tests in place. Not only does this help to ensure that you’ve 
actually fixed the bug, it also helps to ensure you haven’t introduced any new 
bugs in the process. In the absence of automated tests, make sure to carefully 
record the correct output, and check against the inputs that previously failed.
This can be summarized as follows:

* Realise that you have a bug
* Make it repeatable
* Figure out where it is using traceback()
* Fix it and test it

##Debugging in RStudio
The RStudio Article https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio describes the built in Debugging Tools in RStudio.

IMHO, the best you can do is to set the RStudio Option in the menu "Debug/On Error" to "Break in Code". With this option set, RStudio stops execution if an error occurs on the line that threw the error. The environment shows all valid variables. The traceback window shows the call stack.


##Debugging on the console
The following basic tools are available in the console:

* traceback() in the console
* options(error = traceback) for automatation.
* Use `browser()`anywhere in the code. Thus, you have
    - full access to functions an variables - even the ones which are not yet evaluated,
    - all environments available
    - full access to command line (n=next, ls()=list all variables, s=step into function
    f= finish and c=continue) and
    - you can access packages when the --with-keep.source option is set for the 
    present package.
* options(error = browser)
* options(error = recover)

In general you can view the options using `options` or `options("error")`

## Debugging in testthat

When using RStudio GUI button (Strg + Shift + T) commands do not work. Therefore
1. Insert a call to browser() somewhere within the testthat unit tests.
2. Save the changes as there is no auto-save!
3. Run devtools::test() from the RStudio console.

***

# packrat

Packrat is a dependency management system for R. It allows you to make and manage a project specific library that can be shared with your colleagues.

Why you should use this: (quote from the makers website)
> R package dependencies can be frustrating. Have you ever had to use trial-and-error to figure out what R packages you need to install to make someone else’s code work–and then been left with those packages globally installed forever, because now you’re not sure whether you need them? Have you ever updated a package to get code in one of your projects to work, only to find that the updated package makes code in another project *stop* working?

## Getting Started
1. Read, understand and follow https://rstudio.github.io/packrat
2. About packrat and RStudio https://rstudio.github.io/packrat/rstudio.html

### RStudio on Mac OSX
Somehow, the RStudio in built packrat support doesn't work on SCN's MAC OSX.
Reported here: https://support.rstudio.com/hc/en-us/community/posts/206678697-RStudio-0-99-697-doesn-t-recognize-OSX-10-11-Xcode-7-command-line-tools-

### Workflow for setting up packrat

Start on an empty project. (Even if you want to integrate packrat in an existing project. If so just copy your project folder, name one copy _BACKUP, delete every file in the not _BACKUP folder and start). You can later copy back everything bit by bit.
=> This helped SCN, but it's not sure if it really helps or if it's just vodoo.

#### Install packrat
`install.packages("packrat")` don't use the GitHub Version, it did not work for SCN..

#### Initialise packrat
Be sure you're in your project's working directory.  
`packrat::init()` will parse your code (but you don't have any at the moment..) to see what packages you use and install all these packages into the `packrat` subfolder in your project. After that you type `packrat::snapshot()`. Type `packrat::status()` if you get back
> Up to date.

your packrat is setup. Happy you. If not, I can not help you.

#### Put your code back to your project folder
..and run again `packrat::status`. Now packrat finds all the packages you're referencing in your code. You'll get something like

> The following packages are referenced in your code, but are not present
in your library nor in packrat:  
>     DT  
>     LUKSR  
>     RColorBrewer  
>     base64enc  
>     colorspace  
>     data11R  
>     dichromat  
>     geocoder  
>     htmlwidgets  
>     jsonlite  
>     labeling  
>     leaflet  
>     munsell  
>     plot11R  
>     plyr  
>     png  
>     raster  
>     readxl  
>     reshape2  
>     scales  
>     simTimeR  
>     sp  
> You will need to install these packages manually, then use  
> packrat::snapshot() to record these packages in packrat.  

Do it with `install.packages("DT")` etc. This will only install those packages to your packrat library.

After that do `packrat::snapshot()`

You may need to repeat step 3. some times since packrat finds packages recursively.

4. Installing the local packages
After installing all packages available through CRAN or GitHub I ended up with

`packrat::status()`

> The following packages are used in your code, tracked by packrat, but no longer present in your library:
>                from   to
>     LUKSR       0.2   NA
>     data11R     0.1   NA
>     simTimeR    1.1   NA
>
> Use packrat::restore() to restore these libraries.

If you only have these packages locally on your machine, copy the project folders of those packages into `..your-packrated-project-folder/packrat/lib/x86_64-apple-darwin13.4.0/3.2.1/` This path may be different, but it's just the packrat library inside your packrated project. Capisce?

Run `packrat::snapshot()`

Run `packrat::status()`

If you get
> Up to date.

you're set.

No wait. Now your local packages are known by packrat. Still they're not installed as you can verify in the packge tab in RStudio.

You need to install these packages manually from their local sources stored in the "packrat/src" directories.

I had to run:
`install.packages("~/Documents/R/LUKS/packrat/src/cacheR/cacheR_0.1.tar.gz", repos = NULL, type = "source")`

`install.packages("~/Documents/R/LUKS/packrat/src/data11R/data11R_0.1.tar.gz", repos = NULL, type = "source")`

and

`install.packages("~/Documents/R/LUKS/packrat/src/data11R/data11R_0_1.tar.gz", repos = NULL, type = "source")`

Now you're set.

### local.repos option
There is the local.repos option in packrat. This should allow you to do step 4. automatically. It didn't work on the first try for me..

Proof to be done.

### GitHub Installation
After installing `plot11R` v1.0.0 from GitHub with
`devtools::install_github("ims-fhs/plot11R", auth_token = "35b77ed8d745a9572409e6c153e20e36d45094ed", ref = "v1.0.0")` packrat said, that there is a sync difference between my local library and packrat. Obviously since I updated the local library with the new `plot11R`. However `packrat::snapshot()` failed, because it didn't find `plot11R` on GitHub. Probably because it is a private repo..?

I had to find a workaround:

1. Get the source file from GitHub

2. Put it into your local packrat/src folder

3. Install `plot11R` from that source.

Hurray.

***

# OSRM

## How to run the OSRM server on Adrian's Mac.
Open Terminal

`cd /Users/adrianschmid/Documents/OSRM/osrm-backend/build`  
`./osrm-routed switzerland-latet.osrm`

> [info] starting up engines, v4.8.0
> [info] populating base path: switzerland-latest.osrm
> [info] HSGR file:	"switzerland-latest.osrm.hsgr"
> [info] loading graph data
> [info] loading graph from switzerland-latest.osrm.hsgr
> [info] number_of_nodes: 1299323, number_of_edges: 5636126
> [info] loaded 1299323 nodes and 5636126 edges
> [info] Data checksum is 1237576090
> [info] loading edge information
> [info] loading core information
> [info] loading geometries
> [info] loading r-tree
> [info] loading timestamp
> [info] Loading Timestamp
> [info] loading street names
> [info] loaded plugin: table
> [info] loaded plugin: hello
> [info] loaded plugin: locate
> [info] loaded plugin: nearest
> [info] loaded plugin: match
> [info] loaded plugin: timestamp
> [info] loaded plugin: viaroute
> [info] loaded plugin: trip
> [info] http 1.1 compression handled by zlib version 1.2.5
> [info] running and waiting for requests


# git-GUI
Not tested: [ref](http://stackoverflow.com/questions/22046808/how-to-ignore-files-using-git-gui-tcl-tk-application)

the pragmatic way is, to add this to your git configuration:

```
git config --global guitool."Add to .gitignore".cmd $'echo "\n$FILENAME" >> .gitignore & git add .gitignore'
git config --global guitool."Add to .gitignore".needsfile yes
git config --global guitool."Add to .gitignore".confirm yes
```

Usage

After that, you can use it under Tools > Ignore selected file in your git gui. 
Select a file you want to ignore under Unstaged Changes -> Tools/ignore selected file

***

# Appendix: Some useful hooks

Source files are from [here](https://gist.github.com/rmflight/8863882):
Licensed under CC0 (just be nice and point others to where you got this)
Author: Robert M Flight <rflight79@gmail.com>, github.com/rmflight
This is a pre-/ post-commit hooks

To install it, simply copy this into the `.git/hooks/pre-commit` or 
`.git/hooks/pre-commit` file of your git repo, change `/path/2/Rscript`, and make 
it executable. Note that `/path/2/Rscript` is the same as your `/path/2/R/bin/R`, 
or may be in `/usr/bin/Rscript` depending on your installation. 

## Pre-commit hook (Tested)

**Use correct R-version, update when updating R!**
```
#!C:/R/R-3.2.2/bin/x64/Rscript

# In instances where you do NOT want the version incremented, add the environment 
# variable inc=FALSE to your git call e.g. "inc=FALSE git commit -m "commit message".
# This is useful when you change the major version number for example.
inc <- TRUE # default

# get the environment variable and modify if necessary
tmpEnv <- as.logical(Sys.getenv("inc"))
if (!is.na(tmpEnv)) {
  inc <- tmpEnv
}

# check that there are files that will be committed, don't want to increment 
# version if there won't be a commit
fileDiff <- system("git diff HEAD --name-only", intern = TRUE)

if ((length(fileDiff) > 0) && inc) {

  currDir <- getwd() # this should be the top level directory of the git repo
  currDCF <- read.dcf("DESCRIPTION")
  currVersion <- currDCF[1,"Version"]
  splitVersion <- strsplit(currVersion, ".", fixed = TRUE)[[1]]
  nVer <- length(splitVersion)
  currEndVersion <- as.integer(splitVersion[nVer])
  newEndVersion <- as.character(currEndVersion + 1)
  splitVersion[nVer] <- newEndVersion
  newVersion <- paste(splitVersion, collapse = ".")
  currDCF[1,"Version"] <- newVersion
  currDCF[1, "Date"] <- strftime(as.POSIXlt(Sys.Date()), "%Y-%m-%d")
  write.dcf(currDCF, "DESCRIPTION")
  system("git add DESCRIPTION")
  cat("Incremented package version and added to commit!\n")
}

```

## Post-commit hook (Not tested)

**Use correct R-version, update when updating R!**
```
#!C:/R/R-3.2.2/bin/x64/Rscript

# In instances where you do NOT want the version incremented, add the environment 
# variable inc=FALSE to your git call e.g. "inc=FALSE git commit -m "commit message"".
# This is useful when you change the major version number for example.

inc <- TRUE # default

# get the environment variable and modify if necessary
tmpEnv <- as.logical(Sys.getenv("inc"))
if (!is.na(tmpEnv)){
  inc <- tmpEnv
}

if (inc){

  currDir <- getwd() # this should be the top level directory of the git repo
  currDCF <- read.dcf("DESCRIPTION")
  currVersion <- currDCF[1,"Version"]
  splitVersion <- strsplit(currVersion, ".", fixed=TRUE)[[1]]
  nVer <- length(splitVersion)
  currEndVersion <- as.integer(splitVersion[nVer])
  newEndVersion <- as.character(currEndVersion + 1)
  splitVersion[nVer] <- newEndVersion
  newVersion <- paste(splitVersion, collapse=".")
  currDCF[1,"Version"] <- newVersion
  currDCF[1, "Date"] <- strftime(as.POSIXlt(Sys.Date()), "%Y-%m-%d")
  write.dcf(currDCF, "DESCRIPTION")
  system("git add DESCRIPTION")
  system('inc=FALSE git commit -m "increment package version"') # inc=FALSE is 
  #required, otherwise we end up in an infinite loop
  cat("Incremented package version and committed!\n")
}
```

## .gitconfig file (Windows)

After installing kdiff3, you need to adapt your git config file (For convenience, 
I show all of my config file...)
```
[user]
	name = Christoph Strauss
	email = christoph.strauss@fhsg.ch
[merge] # SCN. Check SQC???
	conflictstyle = diff3 # SCN. Check SQC???
[credential]
	helper = wincred # Use helper to avoid typing pwd all the time
[alias]
	hist = log --pretty=format:'%h - %an, %ad: %s' --graph --date=short # Nicly formatted log
[difftool "kdiff3"]
	cmd = 'C:/Program Files/KDiff3/kdiff3' $LOCAL $REMOTE # Use kdiff3
	keepBackup = false
	trustExitCode = false
[filter "lfs"]
	clean = git-lfs clean %f
	smudge = git-lfs smudge %f
	required = true
# [include] 
#   path = 'C:/Users/sqc/.gitconfig' # SQC: Does not work. global options cannot be accesed from anywhere
```
For **MAC** you need to replace
```
[credential]
	helper = osxkeychain
[difftool "kdiff3"]
    tool = kdiff3
    path = /Applications/kdiff3.app/Contents/MacOS/kdiff3
    trustExitCode = false
```
Alternatively you can also use the MAC OSX integrated diff and merge tool 
called "File Merge". Therefore you don't need to change anything in your 
.gitconfig file. If you want to diff two branches just type: `git diff branch1 branch2` 
into the terminal.

If you also set
```
[core]
	editor = 'C:/Program Files/KDiff3/kdiff3' # Set core editor to kdiff3
[diff]
	tool = kdiff3
	guitool = kdiff3
	external = 'C:/Users/sqc/git-diff-wrapper.sh' # Use external wrapper for 7 arguments
```
you run into problems with the nice "commit-editor" in RStudio. Therefore, I do 
not use that any more.

### Work in progress...

Many parts not understood. Identical to stuff above... (18.04.2016 SQC)
```
C:\07 Rprogress\05 Rettung SG>git config --list --show-origin
file:"C:\\ProgramData/Git/config"       core.symlinks=false
file:"C:\\ProgramData/Git/config"       core.autocrlf=true
file:"C:\\ProgramData/Git/config"       core.fscache=true
file:"C:\\ProgramData/Git/config"       color.diff=auto
file:"C:\\ProgramData/Git/config"       color.status=auto
file:"C:\\ProgramData/Git/config"       color.branch=auto
file:"C:\\ProgramData/Git/config"       color.interactive=true
file:"C:\\ProgramData/Git/config"       help.format=html
file:"C:\\ProgramData/Git/config"       http.sslcainfo=C:/Git/mingw64/ssl/certs/ca-bundle.crt
file:"C:\\ProgramData/Git/config"       diff.astextplain.textconv=astextplain
file:"C:\\ProgramData/Git/config"       rebase.autosquash=true
file:"C:\\Git\\mingw64/etc/gitconfig"   credential.helper=manager
file:C:/Users/sqc/.gitconfig    filter.lfs.clean=git-lfs clean %f
file:C:/Users/sqc/.gitconfig    filter.lfs.smudge=git-lfs smudge %f
file:C:/Users/sqc/.gitconfig    filter.lfs.required=true
file:C:/Users/sqc/.gitconfig    user.name=Christoph Strauss
file:C:/Users/sqc/.gitconfig    user.email=christoph.strauss@fhsg.ch
file:C:/Users/sqc/.gitconfig    credential.helper=wincred
file:C:/Users/sqc/.gitconfig    alias.hist=log --pretty=format:'%h - %an, %ad: %s' --graph --date=short
file:C:/Users/sqc/.gitconfig    alias.taghist=log --date-order --graph --tags --simplify-by-decoration --pretty=format:'%ai %h %d'
file:C:/Users/sqc/.gitconfig    difftool.kdiff3.cmd='C:/Program Files/KDiff3/kdiff3' $LOCAL $REMOTE
file:C:/Users/sqc/.gitconfig    difftool.kdiff3.keepbackup=false
file:C:/Users/sqc/.gitconfig    difftool.kdiff3.trustexitcode=false
file:.git/config        core.repositoryformatversion=0
file:.git/config        core.filemode=false
file:.git/config        core.bare=false
file:.git/config        core.logallrefupdates=true
file:.git/config        core.symlinks=false
file:.git/config        core.ignorecase=true
file:.git/config        core.hidedotfiles=dotGitOnly
file:.git/config        remote.origin.url=https://github.com/ims-fhs/Rettung-SG
file:.git/config        remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*
file:.git/config        branch.master.remote=origin
file:.git/config        branch.master.merge=refs/heads/master
file:.git/config        branch.devSCN.remote=origin
file:.git/config        branch.devSCN.merge=refs/heads/devSCN
```

## R-script to calculate story points from symphonical

```
imsbasics::clc()
symphonical <- rjson::fromJSON(file = "swBn2e.json")
cards <- symphonical$board_cards
description <- c()
aufwand <- c()
for (i in 1:length(cards)) { 
  description[i] <- cards[[i]]$description
  aufwand[i] <- strsplit(description[i], split = "Aufwand: ")[[1]][2]
  aufwand[i] <- strsplit(aufwand[i], split = " SP")[[1]][1]
  }
aufwand <- as.numeric(aufwand)
sum(aufwand, na.rm = TRUE)
```

***

